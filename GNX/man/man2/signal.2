.ig
	@(#)signal.2	1.5	10/20/83
	@(#)Copyright (C) 1983 by National Semiconductor Corp.
..
.TH SIGNAL 2 
.SH NAME
signal \- catch or ignore signals
.SH SYNOPSIS
.nf
.B #include <signal.h>
.PP
.B (*signal(sig, func))()
.B void (*func)();
.fi
.SH DESCRIPTION
.IR N.B. :
The system currently supports two signal implementations.
The one described here is standard in version 7 UNIX systems,
and is retained for backward compatabililty.
The one described in
.IR sigsys (2)
as supplemented by
.IR sigset (3)
provides for the needs of the job control mechanisms 
used by
.IR csh (1),
and corrects the bugs in this older implementation of signals,
allowing programs
which process interrupts
to be written
reliably.
.PP
A signal
is generated by some abnormal event,
initiated either by user at a terminal (quit, interrupt),
by a program error (bus error, etc.),
or by request of another program (kill).
Normally all signals
cause termination of the receiving process,
but a
.I signal
call allows them either to be ignored
or to cause an interrupt to a specified location.
Here is the list of standard version 7 signals with names as specified
in the file
.IR /usr/include/signal.h ; 
see
.IR sigsys (2)
for additional signals.
.LP
.nf
.ta \w'SIGMMMM 'u +\w'15*  'u
SIGHUP	\01	hangup
SIGINT	\02	interrupt
SIGQUIT	\03*	quit
SIGILL	\04*	illegal instruction (not reset when caught)
SIGTRAP	\05*	trace trap (not reset when caught)
SIGIOT	\06*	IOT instruction
SIGEMT	\07*	EMT instruction
SIGFPE	\08*	floating point exception
SIGKILL	\09	kill (cannot be caught or ignored)
SIGBUS	10*	bus error
SIGSEGV	11*	segmentation violation
SIGSYS	12*	bad argument to system call
SIGPIPE	13	write on a pipe with no one to read it
SIGALRM	14	alarm clock
SIGTERM	15	software termination signal
	16	unassigned
.fi
.PP
The starred signals in the list above cause a core image
if not caught or ignored.
.PP
If
.I func
is SIG_DFL, the default action
for signal
.I sig
is reinstated; this default is termination,
sometimes with a core image.
If
.I func
is SIG_IGN the signal is ignored.
Otherwise
when the signal occurs
.I func
will be called with the
signal number as argument.
A return from the function will
continue the process at the point it was interrupted.
.PP
Except as indicated,
a signal is reset to SIG_DFL after being caught.
Thus if it is desired to
catch every such signal,
the catching routine must
issue another
.I signal
call.
.PP
If, when using this (older) signal interface,
a caught signal occurs
during certain system calls, the call terminates prematurely.
In particular this can occur
during an
.IR ioctl (2) ,
.IR read (2) ,
or
.IR write (2)
on a slow device (such as a terminal, but not a file);
and during
.IR pause (2)
or
.IR wait (2).
When such a signal occurs, the saved user status
is arranged in such a way that when return from the
signal-catching routine takes place, it will appear that the
system call returned an error status.
The user's program may then, if it wishes,
re-execute the call.
.PP
The value of
.I signal
is the previous (or initial)
value of
.I func
for the particular signal.
.PP
After a
.IR  fork (2)
the child inherits
all signals.
.IR  Exec (2)
resets all
caught signals to default action.
.PP
If a process is using the mechanisms of
.IR sigsys (2)
and
.IR sigset (3)
many of these calls are automatically restarted
(See
.IR sigsys (2)
and
.IR jobs (3)
for details).
.SH "GENIX IMPLEMENTATION"
When a signal occurs,
the kernel does not transfer control directly to the
specified signal handler.
Instead,
the assembly-level routine
.IR sigentry (3)
is called.
This routine saves the temporary registers and
.I psr
flags and then calls the specified signal handler.
When the signal handler returns,
.I sigentry
restores the temporary registers and psr flags and returns to the interrupted
routine.
Such an intermediate routine is necessary because C routines assume
that the registers
.IR r0 ,
.IR r1 ,
.IR r2 ,
and the
.I psr
flags can be used without saving them.
.PP
The
.I crt0
startup module tells the kernel where the
.I sigentry
routine is by executing a
.IR signal (2)
system call using the special signal number SIGCATCHALL.
Then when a signal occurs,
the kernel calls the assembly-level routine in such
that a way that it appears as if the following sequence of instructions
was executed:
.nf
.sp 0.5v
.ta 0.5i +\w'movd'u+(3n) +\w'signal_routine,tos'u+(4n)
	movd	signal_number,tos	; push signal number
	lxpd	signal_routine,tos	; push signal handler descriptor
	cxpd	sigentry	; call low-level routine
.fi
.SH "SEE ALSO"
sigsys(2),
kill(1),
kill(2),
ptrace(2),
setjmp(3),
sigentry(3),
sigset(3)
.SH DIAGNOSTICS
The value (int)\-1 is returned if the
given signal is out of range.
.SH BUGS
For reasons of efficiency,
the floating point registers are not saved
when calling a signal handler.
Thus a signal handler should not use floating
point instructions if it expects to return to the interrupted code.
This problem can be fixed if you write your own version of the
.IR sigentry (3)
routine to save all of the floating point registers.
.PP
The traps should be distinguishable by extra arguments
to the signal handler, and all hardware supplied parameters should
be made available to the signal routine.
.PP
If a repeated signal arrives before the last one can be
reset, it cannot be caught
(however this is
.B not
true if you use
.IR sigsys (2)
and
.IR sigset (3)).
.PP
The type specification of the routine and its
.I func
argument are problematical.
